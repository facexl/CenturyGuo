{"data":{"markdownRemark":{"html":"<blockquote>\n<p>在之前的文章<a href=\"/posts/pre-deep-into-egg-core\">深入egg-core前篇</a>中已经讲述了一个道理，node之所以没有成为一个比较流行的服务器语言，是因为node需要一个企业级的框架。而egg或许是一个不错的选择，针对egg-core的内部实现，将会在这篇文章中作出探索。</p>\n</blockquote>\n<p>初学node来编写server一般都是简单的启动一个挂起的的node进程:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// server.js</span>\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ok'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>启动这个server.js后，会启动一个挂起的node的进程，然后我们访问<a href=\"http://localhost:3000\">页面</a>的时候就会收到返回值了。</p>\n<p>这是比较基本的启动一个node服务的方式，但是这种方式太基础，没有考虑到生产环境的需求。一个服务被部署到生产环境会衍生出一些额外的需求：</p>\n<ul>\n<li>\n<p><strong>可扩展性</strong> 生产环境中，用户的访问量不是像我们启动一个服务器来测试这样小的规模，有的时候会有较大的并发量，我们通常会采用集群的方式来解决这个问题，即发布启动若干个服务，然后让请求负载到这些服务上，就可以将较大的访问量拆解到比较合适的访问量，所以服务的可扩展性是很重要的。node是单进程处理请求的，所以有的时候我们可能会让一个端口的监听事件发布到若干个node进程中，也会起到负载均衡的作用。</p>\n</li>\n<li>\n<p><strong>健壮性</strong> 在egg的<a href=\"https://eggjs.org/zh-cn/core/cluster-and-ipc.html#%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4\">文档</a>中也是有提到的，node在遇到未捕获异常的时候会退出，如果没有一个兜底的处理的话，最后应用会挂掉，这在生产环境中是不可容忍的，针对这点Node提供了<code class=\"language-text\">process.on(&#39;uncaughtException&#39;, handler)</code>来处理这个异常。</p>\n</li>\n</ul>\n<p>egg在这方面有相关的处理，这些处理大部分都被放在<a href=\"https://github.com/eggjs/egg-cluster\">egg-cluster</a>中，在官方文档中，有明确的图阐述了内部的egg-cluster的处理逻辑:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                +--------+          +-------+\n                | Master |&lt;--------&gt;| Agent |\n                +--------+          +-------+\n                ^   ^    ^\n               /    |     \\\n             /      |       \\\n           /        |         \\\n         v          v          v\n+----------+   +----------+   +----------+\n| Worker 1 |   | Worker 2 |   | Worker 3 |\n+----------+   +----------+   +----------+</code></pre></div>\n<p>假如我们启动了一个生产环境的egg服务，我们通常会执行:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">egg-scripts start --daemon --title<span class=\"token operator\">=</span>xxxxx</code></pre></div>\n<p>这里的egg-scripts的命令行工具，我们可以一窥</p>\n<p>在其项目中的<code class=\"language-text\">start.js</code>的脚本中，组装了一些命令行参数，最后会执行<code class=\"language-text\">start-cluster</code>这个node脚本:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">startCluster</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里的framework是什么，默认是egg提供的framework，你也可以像<a href=\"https://eggjs.org/zh-cn/advanced/framework.html\">文档</a>中说的一样，自己定义一个framework，在配置文件中指明使用自己的framework，在framework中，需要被导出一个<code class=\"language-text\">startCluster</code>的函数，这个函数就是这里被调用的函数。在官方默认的egg的framework中，只是直接引用了<code class=\"language-text\">egg-cluster</code>的输出:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exports<span class=\"token punctuation\">.</span>startCluster <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'egg-cluster'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>startCluster<span class=\"token punctuation\">;</span></code></pre></div>\n<p>关注一下<code class=\"language-text\">egg-cluster</code>中的实现，可以发现，startCluster的第一步，就是创建一个Master:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">startCluster</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Master</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ready</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在官方文档中有这样的描述:</p>\n<ul>\n<li><strong>startCluster 启动传入 baseDir 和 framework，Master 进程启动</strong></li>\n<li>\n<p><strong>Master 先 fork Agent Worker</strong></p>\n<ul>\n<li>根据 framework 找到框架目录，实例化该框架的 Agent 类</li>\n<li>Agent 找到定义的 AgentWorkerLoader，开始进行加载</li>\n<li>AgentWorkerLoader，开始进行加载 整个加载过程是同步的，按 plugin > config > extend > agent.js > 其他文件顺序加载</li>\n<li>agent.js 可自定义初始化，支持异步启动，如果定义了 beforeStart 会等待执行完成之后通知 Master 启动完成。</li>\n</ul>\n</li>\n<li>\n<p><strong>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</strong></p>\n<ul>\n<li>App Worker 有多个进程，所以这几个进程是并行启动的，但执行逻辑是一致的</li>\n<li>单个 App Worker 和 Agent 类似，通过 framework 找到框架目录，实例化该框架的 Application 类</li>\n<li>Application 找到 AppWorkerLoader，开始进行加载，顺序也是类似的，会异步等待，完成后通知 Master 启动完成</li>\n</ul>\n</li>\n<li><strong>Master 等待多个 App Worker 的成功消息后启动完成，能对外提供服务。</strong></li>\n</ul>\n<p>在Master的构造函数中，我们会发现，master在创建的时候会检测端口号并启动一个agent服务:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">detectPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    err<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'ClusterPortConflictError'</span><span class=\"token punctuation\">;</span>\n    err<span class=\"token punctuation\">.</span>message <span class=\"token operator\">=</span> <span class=\"token string\">'[master] try get free port error, '</span> <span class=\"token operator\">+</span> err<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    process<span class=\"token punctuation\">.</span><span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>clusterPort <span class=\"token operator\">=</span> port<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">forkAgentWorker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里的<code class=\"language-text\">detectPort</code>之前也没有很多的用到，简单的查看了一下官方的源代码，大致就是逐个端口去监听，检测到一个空闲的端口并返回，将这个端口号赋值在<code class=\"language-text\">options.clusterPort</code>上，我们可以在<code class=\"language-text\">Agent</code>中获取到这个参数:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> agentWorker <span class=\"token operator\">=</span> childprocess<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getAgentWorkerFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">,</span> opt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里的<code class=\"language-text\">getAgentWorkerFile()</code>返回的就是<code class=\"language-text\">egg-cluster</code>中的<code class=\"language-text\">agent_worker.js</code>文件，所以在Master创建的时候，会fork一个agent_worker的子进程，传入的参数就是master的options，因此检测的<code class=\"language-text\">clusterPort</code>会被使用在<code class=\"language-text\">agent</code>中，虽然再官方的framework中并没有使用这个端口，如果使用自定义的agent的话，可以考虑使用一下。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// agent_worker.js</span>\n<span class=\"token keyword\">const</span> Agent <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Agent<span class=\"token punctuation\">;</span>\n<span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">'new Agent with options %j'</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> agent <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Agent</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nagent<span class=\"token punctuation\">.</span><span class=\"token function\">ready</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  agent<span class=\"token punctuation\">.</span><span class=\"token function\">removeListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> startErrorHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  process<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> action<span class=\"token punctuation\">:</span> <span class=\"token string\">'agent-start'</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> <span class=\"token string\">'master'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在agent_worker中，直接创建了Agent的对象，这个Agent是从我们指定的Framework中获取的，在agent成功ready之后会向master发送一个<code class=\"language-text\">agent-start</code>的消息。</p>\n<p>发送了这个消息之后，究竟会发生什么情况？上述的官方的描述中提到</p>\n<blockquote>\n<p>Master 得到 Agent Worker 启动成功的消息，使用 cluster fork App Worker</p>\n</blockquote>\n<p>那么，源码中的事实如何？我们可以搜索一下<code class=\"language-text\">agent-start</code>的关键词。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'agent-start'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onAgentStart<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ......</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">once</span><span class=\"token punctuation\">(</span><span class=\"token string\">'agent-start'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>forkAppWorkers<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>前者大部分时间的情况下就是打印一下agent启动后的信息，后者顾明思议，启动了若干个workers。</p>\n<p>查看了一下<code class=\"language-text\">forkAppWorkers</code>的源码，这可和<code class=\"language-text\">forkAgentWorker</code>这个做法不同，在<code class=\"language-text\">forkAgentWorker</code>中是使用<code class=\"language-text\">childprocess.fork</code>的方式来启动一个子进程的，而<code class=\"language-text\">forkAppWorkers</code>中用了很多的<code class=\"language-text\">cluster</code>库。Node官方是这么说明的：</p>\n<blockquote>\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems, the user will sometimes want to launch a cluster of Node.js processes to handle the load.\n每个node都是单进程运行的。为了充分利用多核系统，开发者期望组建一个node.js进程的集群来处理。</p>\n</blockquote>\n<p>在egg的文档中也举出了这么个例子:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> cluster <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'cluster'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> numCPUs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'os'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">cpus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cluster<span class=\"token punctuation\">.</span>isMaster<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> numCPUs<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cluster<span class=\"token punctuation\">.</span><span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  cluster<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exit'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">,</span> signal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'worker '</span> <span class=\"token operator\">+</span> worker<span class=\"token punctuation\">.</span>process<span class=\"token punctuation\">.</span>pid <span class=\"token operator\">+</span> <span class=\"token string\">' died'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这段代码fork了若干个进程，这些进程都会用于处理监听8000的端口号，在同一个端口号下作了负载，而使用<code class=\"language-text\">childProcess.fork</code>的话，监听相同端口号会失败，因此这就是cluster的用处。</p>\n<p>在egg-cluster中并没有显示的调用<code class=\"language-text\">cluster.fork</code>，可以找到的是它调用了一个叫做<a href=\"https://github.com/node-modules/cfork\">cfork</a>的库。在刚开始看源码的时候就看了一下这个库，但没有太仔细的查看，大致知道这是个充分利用cpu来执行<code class=\"language-text\">cluster.fork</code>的工具，然后针对官方有关健壮性中提到的:</p>\n<blockquote>\n<ul>\n<li>关闭异常 Worker 进程所有的 TCP Server（将已有的连接快速断开，且不再接收新的连接），断开和 Master 的 IPC 通道，不再接受新的用户请求。</li>\n<li>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变。</li>\n<li>异常 Worker 等待一段时间，处理完已经接受的请求后退出。</li>\n</ul>\n</blockquote>\n<p>我一直在寻找对应的代码，因为寻遍了egg-cluster和egg仓库，合理的处理cluster的exit的事件的只有这些代码:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">cluster<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exit'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>worker<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">,</span> signal<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>messenger<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    action<span class=\"token punctuation\">:</span> <span class=\"token string\">'app-exit'</span><span class=\"token punctuation\">,</span>\n    data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> workerPid<span class=\"token punctuation\">:</span> worker<span class=\"token punctuation\">.</span>process<span class=\"token punctuation\">.</span>pid<span class=\"token punctuation\">,</span> code<span class=\"token punctuation\">,</span> signal <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    to<span class=\"token punctuation\">:</span> <span class=\"token string\">'master'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">from</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'app'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>而这个代码的消息最后会调用<code class=\"language-text\">onAppExit()</code>这个函数，而这个函数只是将worker冲workerManager中删除和清除一些监听，充其量就是一个clean的操作，并没有关于<strong>fork一个新的Worker进程</strong>的操作，这是我困惑不已，排除了很多可能后终于在cfork这个仓库中找到了相关的代码，原来之前漏看了很多代码，这个cfork本身就提供了所谓:</p>\n<blockquote>\n<p>Master 立刻 fork 一个新的 Worker 进程，保证在线的『工人』总数不变</p>\n</blockquote>\n<p>本文主要是从官方文档的功能为入口，从源码的角度来验证具体的实现，解析了egg启动后的agent和app的执行顺序，fork workers的实现和worker报错后的行为。还是有很多地方没讲清楚，需要读者自行阅读以下源码。</p>","frontmatter":{"title":"egg的集群管理","date":"25 December, 2018","tag":"node,egg"},"excerpt":"在之前的文章 深入egg-core前篇 中已经讲述了一个道理，node之所以没有成为一个比较流行的服务器语言，是因为node需要一个企业级的框架。而egg或许是一个不错的选择，针对egg-core的内部实现，将会在这篇文章中作出探索。 初学node来编写server…"}},"pageContext":{"slug":"node-cluster-in-egg"}}