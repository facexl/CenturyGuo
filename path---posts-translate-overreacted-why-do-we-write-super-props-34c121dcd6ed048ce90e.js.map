{"version":3,"sources":["webpack:///path---posts-translate-overreacted-why-do-we-write-super-props-34c121dcd6ed048ce90e.js","webpack:///./.cache/json/posts-translate-overreacted-why-do-we-write-super-props.json"],"names":["webpackJsonp","396","module","exports","data","markdownRemark","html","frontmatter","title","date","tag","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,wpkBAA4plBC,aAA8PC,MAAA,0BAAAC,KAAA,oBAAAC,IAAA,2BAA6FC,aAAgBC,KAAA","file":"path---posts-translate-overreacted-why-do-we-write-super-props-34c121dcd6ed048ce90e.js","sourcesContent":["webpackJsonp([60536836248096],{\n\n/***/ 396:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>本文出自<a href=\\\"https://overreacted.io/\\\">overreacted</a>，这是<a href=\\\"https://mobile.twitter.com/dan_abramov\\\">Dan Abramov</a>写的博客，我觉得对很有用所以特意做了这个翻译<a href=\\\"/posts/overreacted\\\">系列</a>，原文链接请查看<a href=\\\"https://overreacted.io/why-do-we-write-super-props/\\\">这里</a></p>\\n</blockquote>\\n<p>听说最近好像<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hooks</a>是一个热议的话题。可笑的是我的第一篇博客和这个相去甚远，我希望能够描述好组件class的内部巧妙的实现。不知道大家对这点是否有兴趣。</p>\\n<p><strong>这些内部巧妙的实现可能对在生产环境中使用React并<em>没有</em>特别大的益处，但是针对那些渴望知道React的内部的人来说会觉得非常有趣。</strong></p>\\n<p>那么第一个例子来了</p>\\n<hr>\\n<p>我这辈子写过无数个<code class=\\\"language-text\\\">super(props)</code>，比如：</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>当然，<a href=\\\"https://github.com/tc39/proposal-class-fields\\\">类属性提案</a>让我们可以跳过这种写法</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>为了使用纯类定义，有一个<a href=\\\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\\\">语法</a>早在2015年React 0.13的时候就已经有计划了。定义<code class=\\\"language-text\\\">constructor</code>并调用<code class=\\\"language-text\\\">super(props)</code>只是在类属性提案提供一个人性化的选择之前作为一个临时的选择</p>\\n<p>所以，让我们回到这个例子的ES2015版本的写法:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</span>    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p><strong>为什么我们需要调用<code class=\\\"language-text\\\">super</code>? 我们可以<em>不</em>调用它么？如果我们调用它，如果我们不传<code class=\\\"language-text\\\">props</code>这个参数会发生什么？还可以传其他什么更多的参数么？</strong> 让我们来了解一下</p>\\n<hr>\\n<p>在Javascipt中, <code class=\\\"language-text\\\">super</code>引用了父类的构造函数。(在我们的例子中，这指向了<code class=\\\"language-text\\\">React.Component</code>的实现)</p>\\n<p>更加重要的是，你在构造函数中不能再调用父类的构造函数<em>之前</em>使用<code class=\\\"language-text\\\">this</code>。Javascript不会让你像这么做：</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// 🔴 还不能使用`this`</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ✅ 嘿，现在可以了</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>针对为什么JavaScript必须让你在使用<code class=\\\"language-text\\\">this</code>之前调用父类的构造函数的原因，这里有个关于类继承的例子:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Person</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> name<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">PolitePerson</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Person</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 🔴 这是不被允许的，详细请看下面</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'Good morning folks!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>在<code class=\\\"language-text\\\">super</code>之前使用<code class=\\\"language-text\\\">this</code><em>假如是</em>允许的. 一个月之后，我们可能修改<code class=\\\"language-text\\\">greetColleagues</code>的实现，并在弹出一个消息的时候使用了name的属性:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'Good morning folks!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'My name is '</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">', nice to meet you!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>但是我们忘记了<code class=\\\"language-text\\\">this.greetColleagues()</code>在调用父类的构造函数之前被调用了，我们会以为<code class=\\\"language-text\\\">this.name</code>已经被初始化了。但是<code class=\\\"language-text\\\">this.name</code>并没有被定义，如你所见，这样的代码任然非常难理解。</p>\\n<p>为了避免这样的问题，<strong>JavaScript必须让你在使用<code class=\\\"language-text\\\">this</code>之前调用父类的构造函数，你<em>必须</em>先调用父类的构造函数</strong>。让父类做它自己的事情！但是这个定义类的限制也同样作用于React的组件定义:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ✅ 好啦！现在能够使用`this`了</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这让我们产生了另一个问题：为什么需要传<code class=\\\"language-text\\\">props</code></p>\\n<hr>\\n<p>你可能会觉得将props传递到父类的构造函数中，这样父类<code class=\\\"language-text\\\">React.Component</code>的构造函数就能够初始化<code class=\\\"language-text\\\">this.props</code></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// React内部</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>其实这里真相已经不远了 - <a href=\\\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\\\">React真正做的事情</a>其实是这样的</p>\\n<p>接下来有个令人不解的问题就是，即使你在调用父类的构造函数的时候没有传递<code class=\\\"language-text\\\">props</code>参数，你也依然可以在<code class=\\\"language-text\\\">render</code>或者其他的成员函数中访问<code class=\\\"language-text\\\">this.props</code>(如果你不相信我，可以自己尝试一下)</p>\\n<p><em>上述</em>的现象是如何产生的？显而易见,这个现象证明了<strong>React还会在调用<em>你的</em>构造函数之后，为生成的实例的<code class=\\\"language-text\\\">props</code>赋值</strong></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token comment\\\">// React内部</span>\\n  <span class=\\\"token keyword\\\">const</span> instance <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  instance<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>所以即使你忘记掉在调用<code class=\\\"language-text\\\">super()</code>的时候传入<code class=\\\"language-text\\\">props</code>，React依然会在构造函数结束之后将<code class=\\\"language-text\\\">props</code>赋值，这就是产生这个现象的原因</p>\\n<p>当React要添加对class的支持的时候，这不只是代表着React单纯的只是支持ES6 class，React的目标是尽可能的支持最宽泛的class的概念。当时还<a href=\\\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\\\">不能够确定</a>ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript或者其他语言那种相对来说用于定义组件会比较好。所以React特意对是否必须调用<code class=\\\"language-text\\\">super()</code>不敢妄自约束 - 即使是ES6的类。</p>\\n<p>那么难道这就意味着你能够使用<code class=\\\"language-text\\\">super()</code>而不去调用<code class=\\\"language-text\\\">super(props)</code>？</p>\\n<p><strong>可能还是不可以这么做，因为这还存在一些问题</strong> 当然，React会在调用构造函数之后为<code class=\\\"language-text\\\">this.props</code>赋值。但是在调用了<code class=\\\"language-text\\\">super</code>和构造函数结束之间<code class=\\\"language-text\\\">this.props</code>还是<code class=\\\"language-text\\\">undefuned</code>:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// Inside React</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">// 你的代码</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 😬 我们忘记了将props传入</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>      <span class=\\\"token comment\\\">// ✅ {}</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 😬 undefined </span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>你也可以做更多的尝试，比如在一些函数中调用<code class=\\\"language-text\\\">this.props</code>，然后在<em>构造函数中</em>调用这些函数，看看结果如何。<strong>这也是为什么我推荐你最好能够总是将props传到父类的构造函数中，即使这并不是严格上必须的</strong></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// ✅ 我们传入了props</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>      <span class=\\\"token comment\\\">// ✅ {}</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// ✅ {}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这确保了<code class=\\\"language-text\\\">this.props</code>在构造函数结束之前就被初始化</p>\\n<hr>\\n<p>这里还有一点，很长的一段时间里，React的使用者都非常的好奇。</p>\\n<p>你可能注意到，当你在class中使用 context api(无论是老的<code class=\\\"language-text\\\">contextTypes</code>或者现在的React16.6的<code class=\\\"language-text\\\">contextType</code>API)，<code class=\\\"language-text\\\">context</code>会作为第二个参数传递到构造函数中。</p>\\n<p>但是我们会像<code class=\\\"language-text\\\">super(props, context)</code>这么写么？我们可以这么做，但是context会用的比较低频，相同的context的问题并不会像props这么多。</p>\\n<p><strong>通过类属性提案，这些问题大多数都能够解决</strong>即使没有明确构造函数的定义，所有的参数都能够自动的传入父类，这让我们可以通过类似于<code class=\\\"language-text\\\">state = {}</code>的表达式来赋值<code class=\\\"language-text\\\">this.props</code>或者<code class=\\\"language-text\\\">this.contxt</code></p>\\n<p>通过 Hooks，我们甚至可以不使用<code class=\\\"language-text\\\">super</code>或者<code class=\\\"language-text\\\">this</code>。但这是下次的话题了</p>\",\"frontmatter\":{\"title\":\"翻译：为什么我们需要些super(props)\",\"date\":\"30 November, 2018\",\"tag\":\"translate,overreacted\"}}},\"pathContext\":{\"slug\":\"translate-overreacted-why-do-we-write-super-props\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-translate-overreacted-why-do-we-write-super-props-34c121dcd6ed048ce90e.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<blockquote>\\n<p>本文出自<a href=\\\"https://overreacted.io/\\\">overreacted</a>，这是<a href=\\\"https://mobile.twitter.com/dan_abramov\\\">Dan Abramov</a>写的博客，我觉得对很有用所以特意做了这个翻译<a href=\\\"/posts/overreacted\\\">系列</a>，原文链接请查看<a href=\\\"https://overreacted.io/why-do-we-write-super-props/\\\">这里</a></p>\\n</blockquote>\\n<p>听说最近好像<a href=\\\"https://reactjs.org/docs/hooks-intro.html\\\">Hooks</a>是一个热议的话题。可笑的是我的第一篇博客和这个相去甚远，我希望能够描述好组件class的内部巧妙的实现。不知道大家对这点是否有兴趣。</p>\\n<p><strong>这些内部巧妙的实现可能对在生产环境中使用React并<em>没有</em>特别大的益处，但是针对那些渴望知道React的内部的人来说会觉得非常有趣。</strong></p>\\n<p>那么第一个例子来了</p>\\n<hr>\\n<p>我这辈子写过无数个<code class=\\\"language-text\\\">super(props)</code>，比如：</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>当然，<a href=\\\"https://github.com/tc39/proposal-class-fields\\\">类属性提案</a>让我们可以跳过这种写法</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>为了使用纯类定义，有一个<a href=\\\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#es7-property-initializers\\\">语法</a>早在2015年React 0.13的时候就已经有计划了。定义<code class=\\\"language-text\\\">constructor</code>并调用<code class=\\\"language-text\\\">super(props)</code>只是在类属性提案提供一个人性化的选择之前作为一个临时的选择</p>\\n<p>所以，让我们回到这个例子的ES2015版本的写法:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"gatsby-highlight-code-line\\\">    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</span>    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p><strong>为什么我们需要调用<code class=\\\"language-text\\\">super</code>? 我们可以<em>不</em>调用它么？如果我们调用它，如果我们不传<code class=\\\"language-text\\\">props</code>这个参数会发生什么？还可以传其他什么更多的参数么？</strong> 让我们来了解一下</p>\\n<hr>\\n<p>在Javascipt中, <code class=\\\"language-text\\\">super</code>引用了父类的构造函数。(在我们的例子中，这指向了<code class=\\\"language-text\\\">React.Component</code>的实现)</p>\\n<p>更加重要的是，你在构造函数中不能再调用父类的构造函数<em>之前</em>使用<code class=\\\"language-text\\\">this</code>。Javascript不会让你像这么做：</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Checkbox</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token comment\\\">// 🔴 还不能使用`this`</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ✅ 嘿，现在可以了</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>针对为什么JavaScript必须让你在使用<code class=\\\"language-text\\\">this</code>之前调用父类的构造函数的原因，这里有个关于类继承的例子:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Person</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">=</span> name<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">PolitePerson</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Person</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 🔴 这是不被允许的，详细请看下面</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>name<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'Good morning folks!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>在<code class=\\\"language-text\\\">super</code>之前使用<code class=\\\"language-text\\\">this</code><em>假如是</em>允许的. 一个月之后，我们可能修改<code class=\\\"language-text\\\">greetColleagues</code>的实现，并在弹出一个消息的时候使用了name的属性:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token function\\\">greetColleagues</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'Good morning folks!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token function\\\">alert</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'My name is '</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>name <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">', nice to meet you!'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>但是我们忘记了<code class=\\\"language-text\\\">this.greetColleagues()</code>在调用父类的构造函数之前被调用了，我们会以为<code class=\\\"language-text\\\">this.name</code>已经被初始化了。但是<code class=\\\"language-text\\\">this.name</code>并没有被定义，如你所见，这样的代码任然非常难理解。</p>\\n<p>为了避免这样的问题，<strong>JavaScript必须让你在使用<code class=\\\"language-text\\\">this</code>之前调用父类的构造函数，你<em>必须</em>先调用父类的构造函数</strong>。让父类做它自己的事情！但是这个定义类的限制也同样作用于React的组件定义:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ✅ 好啦！现在能够使用`this`了</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>state <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span> isOn<span class=\\\"token punctuation\\\">:</span> <span class=\\\"token boolean\\\">true</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这让我们产生了另一个问题：为什么需要传<code class=\\\"language-text\\\">props</code></p>\\n<hr>\\n<p>你可能会觉得将props传递到父类的构造函数中，这样父类<code class=\\\"language-text\\\">React.Component</code>的构造函数就能够初始化<code class=\\\"language-text\\\">this.props</code></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// React内部</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>其实这里真相已经不远了 - <a href=\\\"https://github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js#L22\\\">React真正做的事情</a>其实是这样的</p>\\n<p>接下来有个令人不解的问题就是，即使你在调用父类的构造函数的时候没有传递<code class=\\\"language-text\\\">props</code>参数，你也依然可以在<code class=\\\"language-text\\\">render</code>或者其他的成员函数中访问<code class=\\\"language-text\\\">this.props</code>(如果你不相信我，可以自己尝试一下)</p>\\n<p><em>上述</em>的现象是如何产生的？显而易见,这个现象证明了<strong>React还会在调用<em>你的</em>构造函数之后，为生成的实例的<code class=\\\"language-text\\\">props</code>赋值</strong></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\">  <span class=\\\"token comment\\\">// React内部</span>\\n  <span class=\\\"token keyword\\\">const</span> instance <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">YourComponent</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  instance<span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>所以即使你忘记掉在调用<code class=\\\"language-text\\\">super()</code>的时候传入<code class=\\\"language-text\\\">props</code>，React依然会在构造函数结束之后将<code class=\\\"language-text\\\">props</code>赋值，这就是产生这个现象的原因</p>\\n<p>当React要添加对class的支持的时候，这不只是代表着React单纯的只是支持ES6 class，React的目标是尽可能的支持最宽泛的class的概念。当时还<a href=\\\"https://reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages\\\">不能够确定</a>ClojureScript, CoffeeScript, ES6, Fable, Scala.js, TypeScript或者其他语言那种相对来说用于定义组件会比较好。所以React特意对是否必须调用<code class=\\\"language-text\\\">super()</code>不敢妄自约束 - 即使是ES6的类。</p>\\n<p>那么难道这就意味着你能够使用<code class=\\\"language-text\\\">super()</code>而不去调用<code class=\\\"language-text\\\">super(props)</code>？</p>\\n<p><strong>可能还是不可以这么做，因为这还存在一些问题</strong> 当然，React会在调用构造函数之后为<code class=\\\"language-text\\\">this.props</code>赋值。但是在调用了<code class=\\\"language-text\\\">super</code>和构造函数结束之间<code class=\\\"language-text\\\">this.props</code>还是<code class=\\\"language-text\\\">undefuned</code>:</p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token comment\\\">// Inside React</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props <span class=\\\"token operator\\\">=</span> props<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">// 你的代码</span>\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 😬 我们忘记了将props传入</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>      <span class=\\\"token comment\\\">// ✅ {}</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 😬 undefined </span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>你也可以做更多的尝试，比如在一些函数中调用<code class=\\\"language-text\\\">this.props</code>，然后在<em>构造函数中</em>调用这些函数，看看结果如何。<strong>这也是为什么我推荐你最好能够总是将props传到父类的构造函数中，即使这并不是严格上必须的</strong></p>\\n<div class=\\\"gatsby-highlight\\\" data-language=\\\"js\\\">\\n      <pre class=\\\"language-js\\\"><code class=\\\"language-js\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Button</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">React<span class=\\\"token punctuation\\\">.</span>Component</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">constructor</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">super</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// ✅ 我们传入了props</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>      <span class=\\\"token comment\\\">// ✅ {}</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>props<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// ✅ {}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>这确保了<code class=\\\"language-text\\\">this.props</code>在构造函数结束之前就被初始化</p>\\n<hr>\\n<p>这里还有一点，很长的一段时间里，React的使用者都非常的好奇。</p>\\n<p>你可能注意到，当你在class中使用 context api(无论是老的<code class=\\\"language-text\\\">contextTypes</code>或者现在的React16.6的<code class=\\\"language-text\\\">contextType</code>API)，<code class=\\\"language-text\\\">context</code>会作为第二个参数传递到构造函数中。</p>\\n<p>但是我们会像<code class=\\\"language-text\\\">super(props, context)</code>这么写么？我们可以这么做，但是context会用的比较低频，相同的context的问题并不会像props这么多。</p>\\n<p><strong>通过类属性提案，这些问题大多数都能够解决</strong>即使没有明确构造函数的定义，所有的参数都能够自动的传入父类，这让我们可以通过类似于<code class=\\\"language-text\\\">state = {}</code>的表达式来赋值<code class=\\\"language-text\\\">this.props</code>或者<code class=\\\"language-text\\\">this.contxt</code></p>\\n<p>通过 Hooks，我们甚至可以不使用<code class=\\\"language-text\\\">super</code>或者<code class=\\\"language-text\\\">this</code>。但这是下次的话题了</p>\",\"frontmatter\":{\"title\":\"翻译：为什么我们需要些super(props)\",\"date\":\"30 November, 2018\",\"tag\":\"translate,overreacted\"}}},\"pathContext\":{\"slug\":\"translate-overreacted-why-do-we-write-super-props\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-translate-overreacted-why-do-we-write-super-props.json\n// module id = 396\n// module chunks = 60536836248096"],"sourceRoot":""}